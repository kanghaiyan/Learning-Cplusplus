# Preface

- ***Design***, as I see it, is a static property of software, most often associated with an individual application or library, and is only one of many disciplines needed to create successful software. 
- _**Development**_, on the other hand, is dynamic, involving people, processes, and workflows. Because development is ongoing, it typically spans the efforts attributed to many applications and projects.
- In its most general sense, development includes the design, implementation, testing, deployment, and maintenance of a series of products over an extended period. In short, software development is what we do.

- A key principle - one that helps form the foundation of this multi-volume book - is the profound importance of organization in software. Real-world software is intrinsically complex; however, a great deal of software is needlessly complicated, due in large part to a lack of basic organization - both in the way in which it is developed and in the final form that it takes. 
-  This book is first and foremost about what constitutes well-organized software, and also about the processes, methods, techniques, and tools needed to realize and maintain it.

- Secondly, I have come to appreciate that not all software is or should be created with the same degree of polish. The value of real-world application software is often measured by how fast code gets to market. The goals of the software engineers apportioned to application development projects will naturally have a different focus and time frame than those slated to the long-term task of developing reliable and reusable software infrastructure. Fortunately, all of the techniques discussed in this book pertain to both application and library software - the difference being the extent to and rigor with which the various design, documentation, and testing techniques are applied.

- One thing that has not changed and that has been proven repeatedly is that ***all real-world software benefits from physical design.*** That is, the way in which our  logical content is factored and partitioned within files and libraries will govern our ability to identify, develop, test, maintain, and reuse the software we create. In fact, the architecture that results from thoughtful physical design at every level of aggregation continues to demonstrate its effectiveness in industry every day. Ensuring sound physical design,therefore, remains the first pillar of our methodology, and a central organizing principle that runs throughout this three-volume book - a book that both captures and expands upon my original work on this subject.

- The second pillar of our methodology, nascent in Large-Scale C++ Software Design, involves essential aspects of logical design beyond simple syntactic rendering (e.g., value semantics). Since C++98, there has been explosive growth in the use of templates, generic programming, and the Standard Template Library (STL). Although templates are unquestionably valuable, their aggressive use can impede interoperability in software, especially when generic programming is not the right answer. At the same time, our focus on enterprise-scale development and our desire to maximize hierarchical reuse (e.g., of memory allocators) compels reexamination of the proper use of more mature language constructs, such as (public) inheritance.

- Maintainable software demands a well-designed interface (for the compiler), a concise yet comprehensive contract (for people), and the most effective implementation techniques available (for efficiency). Addressing these along with other important logical design issues, as well as providing advice on implementation, documentation, and rendering, rounds out the second part of this comprehensive work.

- Verification, including testing and static analysis, is a critically important aspect of software development that was all but absent in Large-Scale C++ Software Design and limited to testability only. Since the initial publication of that book, teachable testing strategies, such as Test-Driven Development (TDD), have helped make testing more fashionable today than it was in the 1990s or even in the early 2000s. Separately, with the start of the millennium, more and more companies have been realizing that thorough unit testing is cost-effective (or at least less expensive than not testing). Yet what it means to test continues to be a black art, and all too often “unit testing” remains little more than a checkbox in one’s prescribed SOP (Standard Operating Procedure).

- As the third pillar of our complete treatment of component-based software development, we address the discipline of creating effective unit tests, which naturally double as regression tests. We begin by delineating the underlying concept of what it means to test, followed by how to (1) select test input systematically, (2) design, implement, and render thorough test cases readably, and (3) optimally organize component-level test drivers. In particular, we discuss deliberately ordering test cases so that primitive functionality, once tested, can be leveraged to test other functionality within the same component.

- Much thought was given to choosing a programming language to best express the ideas corresponding to these three pillars. C++ is inherently a compiled language, admitting both preprocessing and separate translation units, which is essential to fully addressing all of the important concepts pertaining to the dimension of software engineering that we call physical design. Since its introduction in the 1980s, C++ has evolved into a language that supports multiple programming paradigms (e.g., functional, procedural, object-oriented, generic), which invites discussion of a wide range of important logical design issues (e.g., involving templates, pointers, memory management, and maximally efficient spatial and/or runtime performance), not all of which are enabled by other languages.

- Since Large-Scale C++ Software Design was published, C++ has been standardized and extended many times and several other new and popular languages have emerged. *(In fact, much of what is presented here applies analogously to other languages (e.g., Java, C#) that support separate compilation units.)* Still, for both practical and pedagogical reasons, the subset of modern C++ that is C++98 remains the language of choice for presenting the software engineering principles described here. Anyone who knows a more modern dialect of C++ knows C++98 but not necessarily vice versa. All of the theory and practice upon which the advice in this book was fashioned is independent of the particular subset of the C++ language to which a given compiler conforms.
- Superficially retrofitting code snippets (used from the inception of this book) with the latest available C++ syntax - just because we’re “supposed to” - would detract from the true purpose of this book and impede access to those not familiar with modern C++. *(Even if we had chosen to use the latest C++ constructs, we assert that the difference would not be nearly as significant as some might assume.)* In those cases where we have determined that a later version of C++ could afford a clear win (e.g., by expressing an idea significantly better), we will point them out (typically as a footnote).

- This methodology, which has been successfully practiced for decades, has been independently corroborated by many important literary references. Unfortunately, some of these references (e.g., stroustrup00) have since been superseded by later editions that, due to covering new language features and to space limitations, no longer provide this (sorely needed) design guidance. We unapologetically reference them anyway, often reproducing the relevant bits here for the reader’s convenience.

- Taken as a whole, this three-volume work is an engineering reference for software developers and is segmented into three distinct, physically separate volumes, describing in detail, from a developer’s perspective, all essential technical aspects of this proven approach to creating an organized, integrated, scalable software development environment that is capable of supporting an entire enterprise and whose effectiveness only improves with time.

## Roadmap

- **Volume I** (the volume you’re currently reading) begins this book with our domain-independent software process and architecture (i.e., how all software should be created, rendered, and organized, no matter what it is supposed to do) and culminates in what we consider the state-of-the-art in physical design strategies.
- **Volume II (forthcoming)** continues this multivolume book to include large-scale logical design, effective component-level interfaces and contracts, and highly optimized, high-performance implementation. 
- **Volume III (forthcoming)** completes this book to include verification (especially unit testing) that maximizes quality and leads to the cost-effective, fine-grained, hierarchical reuse of an ever-growing repository of Software Capital.

## Audience

- This multivolume book is written explicitly for practicing C++ software professionals. The sequence of material presented in each successive volume corresponds roughly to the order in which developers will encounter the various topics during the normal design-implementation-test cycle. This material, while appropriate for even the largest software development organizations, applies also to more modest development efforts.

- Application developers will find the organizational techniques in this book useful, especially on larger projects. It is our contention that the rigorous approach presented here will recoup its costs within the lifetime of even a single substantial real-world application.

- Library developers will find the strategies in this book invaluable for organizing their software in ways that maximize reuse. In particular, packaging software as an acyclic hierarchy of fine-grained physical components enables a level of quality, reliability, and maintainability that to our knowledge cannot be achieved otherwise.

- Engineering managers will find that throttling the degree to which this suite of techniques is applied will give them the control they need to make optimal schedule/product/cost trade-offs. In the long term, consistent use of these practices will lead to a repository of hierarchically reusable software that, in turn, will enable new applications to be developed faster, better, and cheaper than they could ever have been otherwise.
---
